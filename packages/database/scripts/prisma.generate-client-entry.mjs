import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const colors = {
  reset: "\x1b[0m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  cyan: "\x1b[36m",
};

const log = {
  info: (msg) => console.log(`${colors.cyan}[INFO]${colors.reset} ${msg}`),
  success: (msg) =>
    console.log(`${colors.green}[SUCCESS]${colors.reset} ${msg}`),
  warn: (msg) => console.warn(`${colors.yellow}[WARN]${colors.reset} ${msg}`),
  error: (msg) => console.error(`${colors.red}[ERROR]${colors.reset} ${msg}`),
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, "..");
const SRC_DIR = path.resolve(ROOT_DIR, "src");
const PRISMA_DIR = path.resolve(SRC_DIR, "prisma");
const GENERATED_DIR = path.resolve(PRISMA_DIR, "generated");
const OUTPUT_FILE = path.resolve(PRISMA_DIR, "client-factory.generated.ts");

log.info(`Scanning generated clients in: ${GENERATED_DIR}`);

if (!fs.existsSync(GENERATED_DIR)) {
  log.error("Generated folder not found. Please run prisma generate first.");
  process.exit(1);
}

const schemas = fs
  .readdirSync(GENERATED_DIR)
  .filter((file) => {
    const dirPath = path.join(GENERATED_DIR, file);

    if (!fs.statSync(dirPath).isDirectory()) return false;

    const hasClient = fs.existsSync(path.join(dirPath, "client.ts"));
    if (!hasClient) {
      log.warn(`Skipping folder '${file}': 'client.ts' not found inside.`);
      return false;
    }

    return true;
  })
  .sort((a, b) => a.localeCompare(b));

if (schemas.length === 0) {
  log.error(
    "No valid schema folders (with client.ts) found in src/prisma/generated.",
  );
  process.exit(1);
}

log.info(`Found valid clients: ${schemas.join(", ")}`);

// ----------------------
// Generate code sections
// ----------------------

const imports = schemas
  .map((schema) => {
    const Alias = pascal(schema);
    // ✅ 네가 원하는 출력처럼 double quote + ./generated 경로
    return `import { PrismaClient as ${Alias}Client, Prisma as ${Alias}Prisma } from "./generated/${schema}/client";`;
  })
  .join("\n");

const constructors = schemas
  .map((schema) => {
    const Alias = pascal(schema);
    return `  ${schema}: ${Alias}Client,`;
  })
  .join("\n");

const logLevelMap = schemas
  .map((schema) => {
    const Alias = pascal(schema);
    return `  ${schema}: ${Alias}Prisma.LogLevel;`;
  })
  .join("\n");

const prismaTypeExports = schemas.map((s) => `${pascal(s)}Prisma`).join(", ");

const content = `/**
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT MANUALLY.
 * Run "node scripts/generate-client-entry.mjs" to update.
 */
${imports}

/**
 * Schema constructors map (source of truth).
 * - Use "as const" so keys are literal and values keep constructor types.
 */
export const SCHEMA_CONSTRUCTORS = {
${constructors}
} as const;

export type AvailableSchemas = keyof typeof SCHEMA_CONSTRUCTORS;
export type SchemaConstructorMap = typeof SCHEMA_CONSTRUCTORS;

/**
 * Instance type per schema
 */
export type SchemaClientMap = {
  [K in AvailableSchemas]: InstanceType<SchemaConstructorMap[K]>;
};

/**
 * PrismaClient constructor options type per schema (EXACT).
 * This is the key to avoid "accelerateUrl required" issues when using adapter.
 */
export type SchemaClientOptionsMap = {
  [K in AvailableSchemas]: ConstructorParameters<SchemaConstructorMap[K]>[0];
};

/**
 * LogLevel per schema namespace
 */
export type SchemaLogLevelMap = {
${logLevelMap}
};

// ----------------------------------------------------------------------
// [ADDED] Helper Type for Generic Constructor
// ----------------------------------------------------------------------

/**
 * A generic constructor type that works for any schema S.
 * This solves the "Union Constructor" issue in TypeScript.
 */
export type PrismaClientConstructor<S extends AvailableSchemas> = new (
  options: SchemaClientOptionsMap[S],
) => SchemaClientMap[S];

/**
 * Critical helper:
 * Prevent "union constructor" issue by preserving generic key S.
 *
 * Usage:
 *   const Ctor = getConstructor(schema);
 *   const client = new Ctor(options); // Fully typed!
 */
// [MODIFIED] Return type is explicitly defined to help type inference
export const getConstructor = <S extends AvailableSchemas>(
  schema: S,
): PrismaClientConstructor<S> => {
  return SCHEMA_CONSTRUCTORS[schema] as unknown as PrismaClientConstructor<S>;
};

export type { ${prismaTypeExports} };
`;

fs.writeFileSync(OUTPUT_FILE, content, "utf-8");
log.success(`Generated entry file at: ${OUTPUT_FILE}`);

// ----------------------
// Utils
// ----------------------

function pascal(str) {
  return String(str)
    .split(/[-_]/g)
    .filter(Boolean)
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("");
}
